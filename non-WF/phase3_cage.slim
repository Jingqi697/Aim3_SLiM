// Phase 3: population cage simulation

initialize() {

defineConstant("BASE_DIR", "/scratch/cqh6wn/Aim3_SLiM/nonWF/3Phase/");
if (!exists("jobID")) defineConstant("jobID", 1);
defineConstant("REP_ID", jobID);
defineConstant("OUTPUT_FILE", BASE_DIR + "results/true_overdominance_rep" + REP_ID + ".csv");

defineConstant("K_cage", 500); // Population cage size
defineConstant("Cage_gen", 100); // Population cage generation
defineConstant("N_low", 4); // low founder -- 4
defineConstant("N_multi", 20); // multi founder -- 20
defineConstant("L", 23e6);
defineConstant("Rec_rate", 2.4e-8);
defineConstant("Inv_start", 2e6);
defineConstant("Inv_center_start", 5.5e6);
defineConstant("Inv_center_end", 9.5e6); // Inversion 4MB center
defineConstant("Inv_end", 13e6);
defineConstant("Inv_marker", 3e6); // Marker placed at 3MB
defineConstant("MU_total", 3e-9);
defineConstant("DFE_shape", 0.33);
defineConstant("DFE_mean_s", -0.001);
defineConstant("H_dominance", 0.0);

defineConstant("LOG_interval", 1); // Log every generation
initializeSLiMModelType("nonWF");
// Mutations
initializeMutationType("m1", 0.5, "f", 0.0);
m1.convertToSubstitution = F;
initializeMutationType("m2", H_dominance, "g", DFE_mean_s, DFE_shape);
m2.convertToSubstitution = F;
initializeMutationType("m3", 0.5, "f", 0.0);
m3.convertToSubstitution = F;
initializeGenomicElementType("g1", c(m1, m2), c(0.26, 0.74));
initializeGenomicElement(g1, 0, L - 1);
initializeMutationRate(MU_total);
initializeRecombinationRate(Rec_rate);
}

// Founder Populations
1 early(){
sim.readFromPopulationFile(""); // Read from burnin
inds_HET = p1.individuals[p1.individuals.countOfMutationsOfType(m3) == 1]; // Heterozygous population p1, have 1 m3 marker
LF_founders = sample(inds_HET, N_low);
MF_founders = sample(inds_HET, N_multi);
sim.addSubpop("p2", 0);
sim.addSubpop("p3", 0);
sim.killIndividuals(p1.individuals);
p1.removeSubpopulation();
defineConstant("Cage_start", sim.cycle);
defineConstant("Cage_end", sim.cycle + Cage_gen);
}

// Reproduction
reproduction(p2) {
if (!exists("LF_clone")) {
defineConstant("LF_clone", T);
perLine = asInteger(K_cage / N_low);
for (ind in LF_founders)
for (i in 1:perLine)
p2.addCloned(ind);
return;
}
nEggs = p2.individualCount * 2;
for (i in 1:nEggs) {
parents = sample(p2.individuals, 2);
p2.addCrossed(parents[0], parents[1]);
}
}

reproduction(p3) {
if (!exists("MF_clone")) {
defineConstant("MF_clone", T);
perLine = asInteger(K_cage / N_multi);
for (ind in MF_founders)
for (i in 1:perLine)
p3.addCloned(ind);
return;
}
nEggs = p3.individualCount * 2;
for (i in 1:nEggs) {
parents = sample(p3.individuals, 2);
p3.addCrossed(parents[0], parents[1]);
}
}

// Recombination
recombination() {
// If have same arrangements, normal recombination
if (haplosome1.containsMarkerMutation(m3, Inv_marker) == haplosome2.containsMarkerMutation(m3, Inv_marker))
return F;
// 
inInv = (breakpoints > Inv_start) & (breakpoints < Inv_end);
inCenter = (breakpoints > Inv_center_start) & (breakpoints < Inv_center_end);
Rec_inCenter = breakpoints[inCenter];
// If no cross over within inversion, normal recombination
if (!any(inInv))
return F;
// If crossover happen within inversions but outside center, supressed recombination
if (any(inInv & !inCenter)) {
breakpoints = breakpoints[!inInv];
return T;
}
// If odd numbers of crossovers happen within inversion center, supressed recombination
if (size(Rec_inCenter) % 2 == 1) {
breakpoints = breakpoints[!inInv];
return T;
} 
// If even numbers of crossovers happen with inversion center, normal recombination
return F;
}

(Cage_start + 1):(Cage_end) early() {
    for (pop in sim.subpopulations) {

        n = pop.individualCount;

        // Only regulate if population is non-empty
        if (n > 0) {
            if (n > K_cage) {
                keep = sample(pop.individuals, K_cage);
                pop.subsetIndividuals(keep);
            }
        } else {
            catn("Generation " + sim.cycle + ": Population " + pop.id + " extinct.");
        }
    }

    if (sim.cycle == Cage_end)
        sim.simulationFinished();
}

(Cage_start + 1):(Cage_end) late() {
if (sim.cycle % LOG_interval != 0)
return;
// write header 
if (!fileExists(OUTPUT_FILE))
writeFile(OUTPUT_FILE, "Gen,Pop,N,InvFreq,fSTD,fHET,fINV\n");
gen_real = sim.cycle - Cage_start;

n = p2.individualCount;
if (n > 0) {
c = p2.individuals.countOfMutationsOfType(m3);
writeFile(OUTPUT_FILE,
gen_real + ",LF," + n + "," +
sum(c)/(2.0*n) + "," +
sum(c==0)/n + "," +
sum(c==1)/n + "," +
sum(c==2)/n + "\n",
append=T);
} else {
writeFile(OUTPUT_FILE,
gen_real + ",LF,0,NA,NA,NA,NA\n",
append=T);
}

n = p3.individualCount;
if (n > 0) {
c = p3.individuals.countOfMutationsOfType(m3);
writeFile(OUTPUT_FILE,
gen_real + ",MF," + n + "," +
sum(c)/(2.0*n) + "," +
sum(c==0)/n + "," +
sum(c==1)/n + "," +
sum(c==2)/n + "\n",
append=T);
} else {
writeFile(OUTPUT_FILE,
gen_real + ",MF,0,NA,NA,NA,NA\n",
append=T);
}
}
