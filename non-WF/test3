////////////////////////////////////////////////////////////
// DIAGNOSTIC: nonWF cage dynamics
// Test:
//  - each individual produces 2 offspring / generation
//  - population is randomly culled to K_cage each generation
////////////////////////////////////////////////////////////

initialize() {

    defineConstant("BURN_IN_FILE",
        "inversion_polymorphic_job=285_rep=7789951208438124276_freq=0.0895154.txt");

    defineConstant("K_cage", 500);
    defineConstant("N_low", 4);
    defineConstant("N_multi", 20);
    defineConstant("TEST_GEN", 10);   // number of cage generations to test

    defineConstant("L", 23e6);
    defineConstant("Rec_rate", 2.4e-8);

    initializeSLiMModelType("nonWF");

    initializeMutationType("m1", 0.5, "f", 0.0);
    initializeMutationType("m2", 0.0, "g", -0.001, 0.33);
    initializeMutationType("m3", 0.5, "f", 0.0);

    m1.convertToSubstitution = F;
    m2.convertToSubstitution = F;
    m3.convertToSubstitution = F;

    initializeGenomicElementType("g1", c(m1, m2), c(0.26, 0.74));
    initializeGenomicElement(g1, 0, L - 1);

    initializeMutationRate(0.0);
    initializeRecombinationRate(Rec_rate);
}

////////////////////////////////////////////////////////////
// GEN 1: load burn-in and move founders
////////////////////////////////////////////////////////////

1 early() {

    sim.readFromPopulationFile(BURN_IN_FILE);
    p1.individuals.age = 0;

    inds_HET = p1.individuals[
        p1.individuals.countOfMutationsOfType(m3) == 1
    ];

    if (size(inds_HET) < (N_low + N_multi))
        stop("Not enough heterozygotes");

    sim.addSubpop("p2", 0);
    sim.addSubpop("p3", 0);

    LF = sample(inds_HET, N_low);
    remaining = inds_HET[match(inds_HET, LF) == -1];
    MF = sample(remaining, N_multi);

    p2.takeMigrants(LF);
    p3.takeMigrants(MF);

    // freeze survival during founding
    p2.fitnessScaling = 1.0;
    p3.fitnessScaling = 1.0;

    sim.killIndividuals(p1.individuals);
    p1.removeSubpopulation();

    defineConstant("START_GEN", sim.cycle);
}

////////////////////////////////////////////////////////////
// REPRODUCTION
//  - founding generation: clone to ~K
//  - later generations: 2 offspring per individual
////////////////////////////////////////////////////////////

reproduction(p2) {

    // founding clone
    if (sim.cycle == START_GEN + 1) {
        perLine = asInteger(K_cage / p2.individualCount);
        for (ind in p2.individuals)
            for (i in 1:perLine)
                p2.addCloned(ind);
        return;
    }

    // cage dynamics
    for (ind in p2.individuals) {
        p2.addCrossed(ind, ind);
        p2.addCrossed(ind, ind);
    }
}

reproduction(p3) {

    if (sim.cycle == START_GEN + 1) {
        perLine = asInteger(K_cage / p3.individualCount);
        for (ind in p3.individuals)
            for (i in 1:perLine)
                p3.addCloned(ind);
        return;
    }

    for (ind in p3.individuals) {
        p3.addCrossed(ind, ind);
        p3.addCrossed(ind, ind);
    }
}

////////////////////////////////////////////////////////////
// EARLY: random culling to K_cage
////////////////////////////////////////////////////////////

(START_GEN + 2):(START_GEN + TEST_GEN) early() {

    for (pop in sim.subpopulations) {

        n = pop.individualCount;

        if (n > K_cage) {
            survivors = sample(pop.individuals, K_cage);
            victims = pop.individuals[match(pop.individuals, survivors) == -1];
            sim.killIndividuals(victims);
        }
    }
}

////////////////////////////////////////////////////////////
// LOGGING
////////////////////////////////////////////////////////////

(START_GEN + 2):(START_GEN + TEST_GEN) late() {

    catn("Gen " + (sim.cycle - START_GEN) +
         " | p2 N=" + p2.individualCount +
         " p3 N=" + p3.individualCount);

    if (sim.cycle == START_GEN + TEST_GEN)
        sim.simulationFinished();
}
