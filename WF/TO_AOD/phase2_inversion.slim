// Phase 2: Introduce inversion from burn-in state
// Run 1000 independent replicates to capture cases where inversion persists

initialize() {
defineConstant("K_ancestral", 5000);
defineConstant("L", 23e6);
defineConstant("Rec_rate", 2.4e-8);
defineConstant("Inv_start", 2e6);
defineConstant("Inv_center_start", 5.5e6);
defineConstant("Inv_center_end", 9.5e6); // Inversion 4MB center
defineConstant("Inv_end", 13e6);
defineConstant("Inv_marker", 3e6); // Marker placed at 3MB
defineConstant("MU_total", 3e-9);
defineConstant("DFE_shape", 0.33);
defineConstant("DFE_mean_s", -0.001);
defineConstant("H_dominance", 0.0);
defineConstant("Burnin_gen", 10 * K_ancestral);
defineConstant("Inv_burnin_gen", 10 * K_ancestral);
if (!exists("jobID")) defineConstant("jobID", 1);
defineConstant("LOG_interval", 100); // Log every 100 generation
initializeSLiMModelType("WF");
// Mutations
initializeMutationType("m1", 0.5, "f", 0.0);
m1.convertToSubstitution = F;
initializeMutationType("m2", H_dominance, "g", DFE_mean_s, DFE_shape);
m2.convertToSubstitution = F;
initializeMutationType("m3", 0.5, "f", 0.0);
m3.convertToSubstitution = F;
initializeGenomicElementType("g1", c(m1, m2), c(0.26, 0.74));
initializeGenomicElement(g1, 0, L - 1);
initializeMutationRate(MU_total);
initializeRecombinationRate(Rec_rate);
}

// Load Burnin
1 late() {
sim.readFromPopulationFile("burnin_state_K=5000_simID=7165645623120792666.txt");
setSeed(getSeed() + jobID); // Random jobs 
defineConstant("repID", getSeed());
defineConstant("Start_gen", sim.cycle);
catn("Phase 2: Replicate " + jobID);
}

// Introduce inversion
(Burnin_gen + 1) late() {
p1.sampleIndividuals(1).haplosomes[0].addNewDrawnMutation(m3, Inv_marker);
inv_freq = sum(p1.individuals.haplosomes.countOfMutationsOfType(m3)) / (2.0 * p1.individualCount);
catn("Generation " + sim.cycle + ": Inversion introduced. Frequency = " + inv_freq);
}

// Recombination
recombination() {
// If have same arrangements, normal recombination
if (haplosome1.containsMarkerMutation(m3, Inv_marker) == haplosome2.containsMarkerMutation(m3, Inv_marker))
return F;
// 
inInv = (breakpoints > Inv_start) & (breakpoints < Inv_end);
inCenter = (breakpoints > Inv_center_start) & (breakpoints < Inv_center_end);
Rec_inCenter = breakpoints[inCenter];
// If no cross over within inversion, normal recombination
if (!any(inInv))
return F;
// If crossover happen within inversions but outside center, supressed recombination
if (any(inInv & !inCenter)) {
breakpoints = breakpoints[!inInv];
return T;
}
// If odd numbers of crossovers happen within inversion center, supressed recombination
if (size(Rec_inCenter) % 2 == 1) {
breakpoints = breakpoints[!inInv];
return T;
} 
// If even numbers of crossovers happen with inversion center, normal recombination
return F;
}

// True Overdominance
fitnessEffect() { 
    m3_count = individual.countOfMutationsOfType(m3);
    if (m3_count == 1) return 1.01; // 1% fitness boost
    return 1.00;
}

// Tracking

(Burnin_gen + 1):(Burnin_gen + Inv_burnin_gen) late() {
genSinceIntro = sim.cycle - (Burnin_gen + 1); // Number of generations since inversion introduction
inv_freq = sum(p1.individuals.haplosomes.countOfMutationsOfType(m3)) / (2.0 * p1.individualCount);
// Inversion lost, simulation finish
if (inv_freq == 0.0) {
catn("Generation " + genSinceIntro +
": Inversion LOST (rep " + jobID + ")");
sim.simulationFinished();
}
// Inversion fixed, simulation finish
if (inv_freq >= 0.99) {
catn("Generation " + genSinceIntro +
": Inversion FIXED (rep " + jobID + ")");
sim.simulationFinished();
}
// Log every 100 generations
if(genSinceIntro >= 1000 & genSinceIntro % LOG_interval == 0) {
// Log inversion genotypes
numSTD = 0;
numHET = 0;
numINV = 0;
for (ind in p1.individuals) {
invCopies = sum(ind.haplosomes.countOfMutationsOfType(m3));
if (invCopies == 0)
numSTD = numSTD + 1;
else if (invCopies == 1)
numHET = numHET + 1;
else
numINV = numINV + 1;
}
catn("Gen " + genSinceIntro +
" | Job " + jobID +
" | Inv freq: " + inv_freq +
" | STD: " + numSTD +
" HET: " + numHET +
" INV: " + numINV);
}
// At gen 100000, save if polymorphism
if (genSinceIntro == (Inv_burnin_gen - 1)) {
outfile = "inversion_polymorphic_job=" + jobID +
"_rep=" + repID +
"_freq=" + inv_freq + ".txt";
sim.outputFull(outfile);
catn("SUCCESS: Saved " + outfile);
sim.simulationFinished();
}
}
