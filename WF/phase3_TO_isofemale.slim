// Phase 3: population cage simulation

initialize() {
// Output files
defineConstant("BASE_DIR", "/scratch/cqh6wn/AOD_slim/True_overdominance/");
if (!exists("jobID")) defineConstant("jobID", 1);
setSeed(getSeed() + jobID);
defineConstant("REP_ID", jobID);
defineConstant("OUTPUT_FILE", BASE_DIR + "results/true_overdominance_rep" + REP_ID + ".csv");


// Cage parameters
defineConstant("K_Bottle", 50);
defineConstant("NUM_GEN", 100);
defineConstant("N_FOUNDERS", 2);

// Chromosome parameters
defineConstant("L", 23e6);
defineConstant("Rec_rate", 2.4e-8);
defineConstant("Inv_start", 2e6);
defineConstant("Inv_center_start", 5.5e6);
defineConstant("Inv_center_end", 9.5e6);
defineConstant("Inv_end", 13e6);
defineConstant("Inv_marker", 3e6);

// Mutation parameters
defineConstant("MU_total", 3e-9);
defineConstant("DFE_shape", 0.33);
defineConstant("DFE_mean_s", -0.001);
defineConstant("H_dominance", 0.0);
// Model
initializeSLiMModelType("WF");

// m3 inversion marker 
initializeMutationType("m3", 0.5, "f", 0.0);
m3.convertToSubstitution = F;
initializeGenomicElementType("g1", m3, 1.0);
initializeGenomicElement(g1, 0, L-1);
initializeMutationRate(0.0);   // no other mutations
initializeRecombinationRate(Rec_rate);
}


// 
1 late() {
// Create population of heterozygotes
sim.addSubpop("p1", 100);
for (ind in p1.individuals) {
ind.haploidGenome1.addNewMutation(m3, 0.0, Inv_marker);
// genome2 left blank â†’ all heterozygotes
}
HET = p1.individuals[p1.individuals.countOfMutationsOfType(m3) == 1];
founders = sample(HET, N_FOUNDERS);
sim.addSubpop("p2", N_FOUNDERS); 
// p2 = bottle
for (i in 0:(N_FOUNDERS - 1)) {
template = founders[i];
p2.individuals[i].haploidGenome1.removeMutations();
p2.individuals[i].haploidGenome2.removeMutations();
p2.individuals[i].haploidGenome1.addMutations(template.haploidGenome1.mutations);
p2.individuals[i].haploidGenome2.addMutations(template.haploidGenome2.mutations);
}

sim.recalculateFitness();
p1.setSubpopulationSize(0);
defineConstant("START_GEN", sim.cycle);
}

1:200000 early() {
if (!exists("START_GEN")) return;
if (sim.cycle == START_GEN + 1) {
p2.setSubpopulationSize(K_Bottle);
}
}


// Recombination
recombination() {
// If have same arrangements, normal recombination
if (haplosome1.containsMarkerMutation(m3, Inv_marker) == haplosome2.containsMarkerMutation(m3, Inv_marker))
return F;
// 
inInv = (breakpoints > Inv_start) & (breakpoints < Inv_end);
inCenter = (breakpoints > Inv_center_start) & (breakpoints < Inv_center_end);
Rec_inCenter = breakpoints[inCenter];
// If no cross over within inversion, normal recombination
if (!any(inInv))
return F;
// If crossover happen within inversions but outside center, supressed recombination
if (any(inInv & !inCenter)) {
breakpoints = breakpoints[!inInv];
return T;
}
// If odd numbers of crossovers happen within inversion center, supressed recombination
if (size(Rec_inCenter) % 2 == 1) {
breakpoints = breakpoints[!inInv];
return T;
} 
// If even numbers of crossovers happen with inversion center, normal recombination
return F;
}

// True Overdominance
fitnessEffect() { 
    m3_count = individual.countOfMutationsOfType(m3);
    if (m3_count == 1) return 1.05; // 5% fitness boost
    return 1.00;
}


1:200000 late() {
if (!exists("START_GEN")) return;
gensSinceStart = sim.cycle - START_GEN;
if (gensSinceStart < 0) return;
if (gensSinceStart > NUM_GEN) return;
n = p2.individualCount;
if (n > 0) {
m3_counts = p2.individuals.countOfMutationsOfType(m3);
f_std = sum(m3_counts == 0) / n;
f_het = sum(m3_counts == 1) / n;
f_inv = sum(m3_counts == 2) / n;
inv_freq = sum(m3_counts) / (2.0 * n);
line = REP_ID + "," + gensSinceStart + "," + n + "," + inv_freq + "," + f_std + "," + f_het + "," + f_inv;
writeFile(OUTPUT_FILE, line, append=T);
// Log gen0
if (gensSinceStart == 0) {
catn("Gen 0 | Cage: " + " | HET: " + format("%.3f", f_het));
}
}
if (gensSinceStart >= NUM_GEN) {
sim.simulationFinished();
}
}
