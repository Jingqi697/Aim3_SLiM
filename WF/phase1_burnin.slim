// Phase 1: Load burn-in
// Allow recessive deleterious mutations to spread throughout the population

initialize() {
//Parameters
defineConstant("K_ancestral", 5000); // Population size 5000
defineConstant("L", 23e6); // Chromosome 2L
defineConstant("Rec_rate", 2.4e-8); // Recombination rate
defineConstant("Inv_start", 2e6); 
defineConstant("Inv_end", 13e6); // 11 MB inversion
defineConstant("MU_total", 3e-9); // Mutation rate
defineConstant("DFE_shape", 0.33); // gamma distribution shape
defineConstant("DFE_mean_s", -0.001); // Mean selection coefficient
defineConstant("H_dominance", 0.0); // Fully recessive
defineConstant("Burnin_gen", 10 * K_ancestral); // Burn-in gen = 10N
// Model setup
initializeSLiMModelType("WF");
// Neutral mutation m1
initializeMutationType("m1", 0.5, "f", 0.0);
m1.convertToSubstitution = F;
// Deleterious mutation m2
initializeMutationType("m2", H_dominance, "g", DFE_mean_s, DFE_shape);
m2.convertToSubstitution = F;
// Inversion marker m3
initializeMutationType("m3", 0.5, "f", 0.0);
defineConstant("Inv_marker", integerDiv(Inv_start + Inv_end, 2));
initializeGenomicElementType("g1", c(m1, m2), c(0.26, 0.74)); // 26% neutral, 74% deleterious
initializeGenomicElement(g1, 0, L-1); // Standard chromosome
initializeMutationRate(MU_total);
initializeRecombinationRate(Rec_rate);
}

// Population
1 early() {
sim.addSubpop("p1", K_ancestral); // Ancestral population p1
defineConstant("simID", getSeed());
}

2:Burnin_gen early() {
if (sim.cycle > 2 & sim.cycle % 1000 == 0) {
meanFit = mean(p1.cachedFitness(NULL));
catn("Gen: " + (sim.cycle - 1) +
" | mean fitness: " + meanFit);
}
}

// Logging
1:Burnin_gen late() {
if (sim.cycle % 1000 == 0) {
// Total deleterious mutation count 
total_m1 = sum(p1.individuals.haplosomes.countOfMutationsOfType(m1));
total_m2 = sum(p1.individuals.haplosomes.countOfMutationsOfType(m2));
// Homozygous deleterious burden
hom_m2 = 0; 
for (ind in p1.individuals) { 
m2id1 = ind.haploidGenome1.mutationsOfType(m2); 
m2id2 = ind.haploidGenome2.mutationsOfType(m2); 
hom_m2 = hom_m2 + size(setIntersection(m2id1, m2id2)); 
}
catn("Gen: " + sim.cycle +
" | N: " + p1.individualCount +
" | m1 copies: " + total_m1 +
" | m2 copies: " + total_m2 +
" | homozygous m2: " + hom_m2);
}
}

// Output
Burnin_gen late() { 
catn("Burn-in complete");
sim.outputFull("burnin_state_K=" + K_ancestral + "_simID=" + simID + ".txt");
sim.simulationFinished();
}
















